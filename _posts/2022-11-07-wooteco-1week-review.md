---
layout: single
title: "[우테코-프리코스] 1주 차 회고"
categories:
tag: [wooteco]
categories: [wooteco]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

[1주차 프리코스 PR 링크](https://github.com/woowacourse-precourse/java-onboarding/pull/593)

# 1. 정적 메소드 (static method)

**static** : '클래스의', '공통적인' 의 사전적 의미

 프로그램 실행 중 클래스가 사용되면 JVM은 해당 클래스파일을(*.class)을 읽어서 클래스에 대한 정보를 메서드 영역에 저장한다. 즉, 클래스 데이터에 static 메소드가 포함되고, 클래스 데이터는 Method Area 에 저장된다. Method Area는 클래스 시작과 동시에 생성되고 프로그램이 끝날 때까지 메모리에 남아 있는다.

![JVM 메모리 구조](/assets/images/JVMmemory.png "JVM 메모리 구조")

그렇다면, static method를 사용하면 항상 메모리에 존재하기 때문에 인스턴스를 생성해 부르는 메소드 보다 더 빠르게 사용 가능하다. 속도가 빠르며 반복적인 사용이 많을 경우 매우 효율적이다. 또 객체를 생성하지 않고도 자원에 접근이 가능하다.

static의 장점만 살펴보면 매우 효율적인 방식이다. 하지만 객체지향언어 Java의 정체성과는 멀어질 수 있다.

### 정적 메소드는 객체지향과 거리가 멀다

static은 객체지향보다 절차지향에 가까운 키워드다. C언어의 전역변수 / 전역함수 와 비슷한 성격을 가지고 있다.

 첫째, 정적 메소드는 객체의 생성주기와 관계가 없다는 점은 객체 지향의 메시지 전달(message passing)을 위반한다.

> 메시지 전달(message passing) : 한 객체에서 다른 객체로 데이터를 전달하거나, 다른 객체의 메소드를 실행시키는 것

객체지향언어는 객체들간 관계를 맺고 메시지를 통해 정보를 교환한다. 메시지 전달을 통해 결과를 반환하는 것이 객체지향적이라 말할 수 있다. 하지만 정적 메소드는 다른 객체와 관계를 맺고있지 않고, 그저 함수를 호출하는 것에 불과하다.

둘째, 정적 메소드는 객체지향의 특징인 다형성을 위반한다. 정적 메소드는 오버라이딩(overriding)과 동적 바인딩(Dynamic Binding)이 불가능하다. 따라서 인터페이스를 구현하는 데 사용할 수 없다.

셋째, 정적 메소드는 객체지향의 특징인 캡슐화를 위반한다.

### 해결법? 정적 팩토리 메서드

정적(static) 팩토리(factory) 메서드 : 객체 생성의 역할을 하는 클래스 메서드

> 팩토리(factory) : GoF 디자인 패턴 중 팩토리 패턴에서 유래한 단어이다. 팩토리는 객체를 생성하는 역할을 분리하겠다는 취지를 담고 있다.

여기서 한가지 의문점이 생긴다. 객체 '생성자'가 존재하는데, 왜 정적 팩토리 메서드를 사용하는가? 자바의 바이블이라 불리는
 `이펙티브 자바` 의 **"아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라"**. 저서의 첫 주제부터 생성자 대신 정적 팩터리 메서드를 고려하라고 말한다. 이로써 정적 팩토리 메서드사용이 매우 효율적임을 알 수 있다.

첫째, 정적 팩토리 메서드를 사용하면 이름을 가질 수 있다. 생성자를 통해 객체를 설정할 때, 코드를 직접 구현한 사람이 아니라면 객체의 속성이 무엇인지 일일이 찾아야 한다. 하지만 정적 팩터리 메서드를 통해 의도가 드러난 생성자를 사용한다면 생성한 객체가 무엇인지 쉽게 파악할 수 있다.

둘째, 호출할 때 마다 새로운 객체를 생성할 필요가 없다.

셋째, 하위 자료형 객체를 반환할 수 있다. 정적 팩토리 메서드는 반환 값을 가지고 있다. 이를 통해 상속을 사용할 수 있고, 하위 자료형의 객체를 반환할 수 있다.

넷째, 객체 생성을 캡슐화할 수 있다.

# 2. `public` 과 `private`은 언제 사용해야 할까?

 `public`과 `private`은 `접근 제어자(Access Modifier)`이다. 접근 제어자는 접근 허용을 제어하는 키워드 이다. 외부에서 어떤 클래스에서라도 접근이 가능한 경우 `public`을 사용하고, 같은 클래스내 접근만 허용하고 싶은 경우 `private`을 사용한다.

 그렇다면 접근 제어자를 왜 사용할까? 캡슐화를 위해 사용하고, 크게 2가지 이유로 생각할 수 있다.

1. **외부로부터 데이터를 보호한다.**

   접근 제어자는 데이터가 유효한 값을 유지하도록 한다. 비밀번호와 같은 데이터는 외부의 접근을 제한하는 것이 필요하고, 이것을 `데이터 감추기(data hiding)`라고 한다. 이는 객체지향개념의 `캡슐화(encapsulation)`에 해당하는 내용이다.

2. **내부에서만 사용하는 멤버들은 외부에 불필요하게 공개하지 않는다.**

   내부 작업을 위해 임시로 사용되는 변수, 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감춘다. 굳이 외부의 접근이 필요가 없다면 노출시킬 필요가 없고, 이는 복잡성을 줄여준다. 이는 `캡슐화(encapsulation)`에 해당한다.

이 두 가지 내용을 머릿속에 염두해 두며, 접근 제어자를 선택한다. 공개할지, 내부에 감출지 선택은 본인의 몫이다. 하지만 `private`은 테스트 클래스에서 호출할 수 없어 일반적으로 테스트가 불가능하다. `Java Reflection`을 통해 임시적으로 접근 가능하게 하여 테스트를 진행할 수 있지만 번거로움이 따른다.

# 3. TDD?

개발자가 필수로 가지고 있어야 하는 역량은 무엇일까? 당연히 **필요한 기능을 빠르게 구현**할 수 있는 것이다. 여기서 빠르게 라는 단어를 빼고, 필요한 기능을 구현하기 위해서는 무엇이 필요할까? 내가 구현한 기능이 제대로 구현 했는지 어떻게 검증을 할 수 있을까? 바로 `테스트` 이다.

그렇다면 `테스트`는 무엇일까? 개발자에게 테스트는 `Software Test`를 의미한다. 제품 또는 서비스의 품질을 확인하고, 소프트웨어의 버그를 찾는 것이 테스트 이다. 제품(함수, 기능, 성능 등)이 예상하는 대로(원하는 대로)동작 하는지 확인 하는 것이다.

테스트들의 프로세스는 "내가 작성한 코드가 -> 기대하는 값 대로 작동 -> 을 하는지 확인"하는 프로세스 이다.

그렇다면 `TDD`는 무엇인가? 테스트 주도 개발(Test-Driven Development)을 의미한다. 먼저 특정한 기능을 세분화 해서 한 가지의 케이스에 대해서 테스트를 작성한다. 이를 테스트 하면 당연히 `fail`이 뜨고, 이를 통과할 수 있는 만큼의 코드를 작성해서 다시 테스트를 수행해 통과시키는 과정을 반복하는 것이 `TDD`이다.

![TDD Process](/assets/images/TDDprocess.png "TDD Process")

TDD를 통해 기능 구현이 완료되면 이를 통해 `refactoring`을 진행해 코드의 질을 높인다.

TDD는 왜 사용할까? TDD는 작성하고자 하는 요구 사항 분석 및 이해가 기반이 되고, 설계자의 관점에서 코드를 작성해 나갈 수 있기 때문이다. 프로그래머는 모든 요구 사항(목표)에 대해 점검할 수 있고, 사용자 입장에서 코드를 작성할 수 있다.

TDD를 잘하기 위해서는 어떤 학습과정이 필요한가?

1. 단위 테스트를 연습

   내가 사용하는 API 사용법을 익히기 위한 학습 테스트에서 시작한다. 만약 처음 사용하는 API를 사용한다면 대부분 main 메서드를 통해 정상적으로 동작하는지 확인한다. 이를 단위 테스트 코드를 작성해 확인해 보자. 자바 String 클래스의 다양한 메소드(함수) 사용법, 자바 ArrayList에 데이터를 추가, 수정, 삭제하는 방법을 단위 테스트의 기본 연습으로 시작한다.

   내가 구현한 메소드 중 Input 과 Output이 명확한 클래스 메소드에 대한 단위 테스트 연습을 한다.

   만약 알고리즘을 학습한다면 알고리즘 구현에 대한 검증을 단위 테스트로 한다. 알고리즘은 Input 과 Output이 명확하다.

2. 단위 테스트가 익숙해 지면 TDD 연습을 시작한다

   TDD 연습 원칙
   첫째, 토이 프로젝트를 이용해 연습한다. 실전에서 TDD를 바로 적용시키는 것은 불가능 하다. 현업의 프로젝트는 매우 거대하고 이를 TDD를 통해 구현할 수 있는 신입 개발자는 존재할 수 없다. 간단한 기능을 가지는 프로젝트를 통해 연습한다.

   TDD Cycle : Test fail -> Test Sucess -> refactoring 무한 반복
   refactoring은 초반에는 제쳐두고 Test 실패, 성공에 집중해서 연습한다. 이것만 해도 너무 벅찬 과정이다.

3. Refactoring 연습

   리팩토링이란 읽기 좋은 코드를 만드는 것이다. 읽기 좋게 테스트 대상 코드(프로덕션 코드)를 개선하는 연습을 한다. 테스트 코드는 변경할 필요가 없다. 읽기 좋은 코드를 만들기 위해서는 **'메서드 분리', '클래스 분리'**가 필요하다.

   **메서드 분리**

   - 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.
   - else 예약어를 쓰지 않는다.
   - 메서드가 한 가지 일만 하도록 구현한다.
   - 로컬 변수가 필요한가?

   **클래스 분리**

   - 모든 원시값과 문자열은 포장한다.
   - 일급 Collection을 사용한다.
   - 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

4. 토이 프로젝트 난이도 높이기

   점진적으로 연습의 난이도를 높인다. 즉 기능 요구 사항을 늘리며 연습한다.
   게임을 만들거나, 의존관계(모바일, 웹 UI, DB, 외부 API)가 없이 연습한다.

5. 의존관계 추가를 통한 난이도 높이기 (현업 단계의 프로젝트)

# 4. 의미 있는 commit message

 지금까지 내 Github의 커밋 메시지를 살펴보면 어떠한 내용인지 파악하기 어렵다. 내가 직접 커밋한 내용이지만 시간이 지나니 직접 커밋을 눌러 내용을 확인하기 전까지 정확히 무슨 작업을 했는지 알아보기가 어려웠다. 기본서를 공부할 때 작성한 예제 코드도 어떤 챕터의 예제인지는 알 수 있지만, 정확히 예제 코드가 어떤 개념에 대한 코드인지 알기가 어려웠다. 이를 현업까지 끌어와 생각하면 참담하다. 협업을 진행할 때, 시간이 지나 이 커밋이 무슨 내용인지 물어보면 내가 바로 답할 수 있을까? 불가능 하다.

커밋 메시지도 일종의 문서 이다. 읽고 무슨 내용인지 흐름을 파악할 수 없다면 필요가 없다. 사람이 읽는 문서이기 때문에 사람이 이해하기 쉬워야 한다.

> 참고 url
>
> - [정적 메소드](https://tecoble.techcourse.co.kr/post/2020-07-16-static-method/)
> - [정적 팩토리 메서드](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)
> - [TDD 학습과정](https://www.youtube.com/watch?v=cVxqrGHxutU&t=1698s&ab_channel=OKKY)
> - [Angular JS Commit Message Convention](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)